# C++基础

## 基础语法
### 1、static与普通变量的区别？常量存储在哪里？static变量又是存储在哪里？
* static与普通auto变量相比，static强调唯一一份，内存里只有一份拷贝。  
* static修饰函数变量，在下次调用该函数时，static变量维持上次调用得到的值。  
* static修饰模块，即static修饰的模块中的作用范围仅限于该模块。  
* static修饰类成员变量，static成员变量属于整个类所有，而不依赖于类的实例。  
* static变量存储在全局/静态存储区

### 2、const和static关键字用法
static见1，const强调不变，不变的变量，即常量，static强调独一份。  
* const修饰普通变量，则不能改变其值。  
* const修饰函数的形参，使得函数不能改变参数的值。  
* const修饰类的成员函数，表明该成员函数不会修改成员变量的值，如果想要在const的成员函数中修改成员变量，则成员变量需添加mutable关键字。  
* const修饰的类的成员变量需要在初始化列表中初始化，static修饰的类的成员变量需要在类外去做初始化，当然也有例外例如简单的内置数据类型int可以在类中直接初始化。  
》》那么底层是如何保证const变量不会被改变呢？  

### malloc和new
new和delete是C++的关键字，在使用时其实分为两步，一步是分配内存，二步是调用构造函数（析构函数），而malloc和free是库函数，不会调用构造函数和析构函数。  
new在分配内存时，会调用malloc函数或者mmap函数，malloc函数用于堆空间的分配，mmap函数来分配内存映射区。new会自动计算需要分配的空间，malloc需要指定大小，new会返回指定类型的指针，malloc返回void*指针。  
》》free和delete如何知道自己要释放的空间大小  
C++做法是在分配数组空间时多分配4个字节大小，专门保存数组的大小，这样delete的时候就会知道需要析构多少次了。  
》》分配内存失败C和C++各会怎么样  
malloc分配内存失败后返回NULL，因此在使用的时候需要判断是否为空。  
new失败会抛出bad_alloc，需要捕获异常，调用异常处理函数。标准推荐做法，使用set_new_handler函数处理new失败，operator new不能满足内存分配请求时，new_handler函数不只调用一次，而是不断重复，直至找到足够的内存。  

## static_cast/dynamic_cast/const_cast/reinterpret_casrt四个强制类型转换
static_cast静态转换，编译时转换；dynamic_cast运行时转换，用于将基类的指针或引用转换成派生的指针或引用；const_cast去掉常量属性；reinterpret_cast对二进制进行重新解释，但不改变其值。  

## 异常捕获与处理 try/catch/throw的使用
C++异常是指在程序运行时发生的反常行为，这些行为超出了函数正常功能的范围。当程序的某部分检测到一个它无法处理的问题时，需要用到异常处理。异常提供一种转移程序控制权的方式。C++异常处理涉及到三个关键字：try，catch，throw。  
在C++语言中，异常处理包括：  
（1）throw表达式：异常检测部分throw表达式来表示它遇到了无法处理的问题，throw引发了异常。throw表达式包含关键字throw和紧随其后的一个表达式，其中表达式的类型就是抛出的异常类型。throw表达式后面通常紧跟一个分号，从而构成一条表达式语句。  
（2）try语句块：异常处理部分try语句处理异常。try语句块以关键字try开始，并以一个或多个catch子句结束。try语句块中代码抛出的异常通常会会被某个catch子句处理。因为catch子句处理异常，所以他们也被称作异常处理代码。catch子句包括三部分：关键字catch，括号内一个

## 数组指针和指针数组
数组指针：
```
int (*p)[n];
```
()优先级高，首先说明p是一个指针，指向一个整型的一维数组，这个一维数组长度是n，也可以说是p的步长。也就是说执行p+1时，p要跨过n个整型数据的长度。  
如果将二维数组赋给一指针，应这样赋值：  
```
int a[3][4];
int (*p)[4]; // 该语句定义一个数组指针，指向含4个元素的一维数组。  
p = a; // 将该二维数组的首地址赋给p，也就是a[0]或&a[0][0];
p++; //该语句执行过后，也就是p = p + 1; p跨过行a[0][]指向行a[1][];
```
所以数组指针也称指向一维数组的指针，亦称行指针。  
指针数组：
```
int* p[n];
```

## 面向对象
### 1、C++面向对象的特性
封装、继承和多态  
封装，隐藏实现细节，实现代码模块化  
继承，派生类继承基类的成员函数和成员变量，实现代码的重用。  
多态，即一个接口多种实现，利用虚函数，派生类override基类的虚函数。  

### 2、一个类声明的时候默认有哪些东西？
默认构造函数、析构函数、拷贝赋值构造函数，移动赋值构造函数、拷贝赋值运算符和移动赋值运算符。  

### 3、构造函数能不能是虚函数，原因：
构造函数不能是虚函数  
<font color=#ff000>TODO 更具体的答案</font>

### 4、虚析构函数及其作用？
当一个基类指针指向一个派生类对象，delete该基类指针时，会先执行派生类的析构函数，然后再执行基类的析构函数，如果没有把析构函数设置为虚函数，则会先执行基类的析构函数，容易造成内存泄漏。  

### 5、虚函数与纯虚函数的区别
纯虚函数仅提供一个函数接口，不提供具体实现，带有纯虚函数的类也称为抽象类，抽象类不能直接实例化，而是由派生类继承抽象类，overrider虚函数，完成虚函数的实现。  

## STL标准库
### 1、STL中vector和map底层原理
vector底层是一块连续的内存，类似于array或者数组，但是vector的大小是可变的，vector在VS下是1.5倍扩容，在GCC下是2倍扩容，写操作的时间复杂度是O(1)，读操作的时间复杂度也是O(1)，一般如果能预估vector中元素的大小，建议使用resize或者reserve先调整vector的大小，在使用vector时会有一定的性能提升。  
map底层是颗红黑树，红黑树是由红色节点和黑色节点组合，根节点一定是黑节点，红节点的子节点一定是黑节点，任意节点到它下面的叶子节点（NULL节点）经过黑节点数量相同，插入时最多旋转三次。  

### 2、deque实现原理
deque是由一段一段的定量连续空间构成。一旦有必要在deque的前端或尾端增加新空间，便配置一段定量连续空间，串接在整个deque的头端或尾端。deque使用map来管理这些内存空间。


## 编译原理
### 1、简述C++编译过程
预处理、编译、汇编、链接。预处理（完成一些预处理指令）进行一些代码的替换和插入等，编译将代码编译成汇编代码，汇编将汇编代码生成机器指令，链接则是利用汇编后得到的文件生成可执行文件。  

## GCC命令
-c，只编译，不链接成可执行文件，编译器只是由输入的.c等源代码文件生成.o为后缀的目标文件，通常编译不含主程序的子程序文件。  
-o output_filename，确定输出文件的名称为output_filename，同时这个名称不能和源文件同名，如果不给出这个选项gcc就给出预设的可执行文件a.out  
-g，产生符号调试工具（GNU的gdb）所必要的符号咨讯，要想对源代码进行调试，我们就必须加入这个选项。  
-O，对程序进行优化编译、链接，采用这个选项，整个源代码会在编译、链接过程中进行优化处理，这样产生的可执行文件的执行效率可以提高，但是，编译、链接的速度就相应地要慢一些。  
-O2，比-O更好的优化编译、链接，当然整个编译、链接过程会更慢。  
-l dirname，将dirname所指出的目录加入到程序头文件目录列表中，是在预编译过程中使用的参数。  

## GDB命令  
gdb是一个Linux下命令行调试工具  
如果需要使用gdb调试程序，请在gcc时加上-g选项  
### 1、基本命令
1）进入GDB
```
# gdb test
```
test是要调试的程序，由gcc test.c -g -o test生成。进入后提示符变为(gdb) 。  
2）查看源码
```
(gdb)I
```
源码会进行行号提示。  
如果需要查看在其他文件中定义的函数，在l后加上函数名即可定位到这个函数的定义及查看附近的其他源码。或者：使用断点或单步运行，到某个函数处使用s进入这个函数。  
3）设置断点
```
(gdb) b 6
```
这样会在运行到源码第6行时停止，可以查看变量的值、堆栈情况等；这个行号是gdb的行号。  
4）查看断点处情况  
```
(gdb) info b
```
可以键入"info b"来查看断点处情况，可以设置多个断点；  
5）运行代码  
```
(gdb) r
```
6）显示变量值  
```
(gdb)p n
```
在程序暂停时，键入"p 变量名"(print)即可；  
GDB在显示变量值时都会在对应值之前加上"$N"标记，它是当前变量值的引用标记，以后若想再次引用此变量，就可以直接写作"$N"，而无需写冗长的变量名；  
7）观察变量
```
(gdb)watch n
```
在某一循环处，往往希望能够观察一个变量的变化情况，这时就可以键入命令"watch"来观察变量的变化情况，GDB在"n"设置了观察点；
8）单步运行
```
(gdb) n
```
9）程序继续运行
```
(gdb) c
```
使程序继续往下运行，直到再次遇到断点或程序结束；  
10）退出GDB
```
(gdb) q
```
### 2、断点调试

### 3、多线程调试
https://blog.csdn.net/zhangye3017/article/details/80382496  
```
(gdb) info threads
查看线程
(gdb) bt
查看当前线程的栈结构（默认是主线程）
(gdb) thread 2
切换线程，2代表第2个线程
```

## 并发
### atomic
