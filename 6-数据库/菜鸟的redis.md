## 第3章 Redis命令
### 3.1 字符串
redis的字符串就是一个有字节组成的序列，它们和很多编程语言里面的字符串没有什么明显的不同，跟C或者C++风格的字符数组也相去不远。在Redis里面，字符串可以存储一下3种类型的值。
* 字节串（byte string）
* 整数
* 浮点数  
用户可以通过给定一个任意的数值，对存储着整数或者浮点数的字符串执行自增（increment）或者自减（decrement）操作，在有需要的时候，redis还会将整数转换成浮点数。整数的取值范围和系统的长整数（long integer）的取值范围相同，而浮点数的取值范围和精度则与IEEE 754标准的双精度浮点数（double）相同。Redis明确地区分字符串、整数和浮点数的做法是一种优势，比起只能够存储字节串的做法，redis的做法在数据表现方面具有更大的灵活性。  


### 3.2 列表
redis的列表允许用户从序列的两端推入或者弹出元素，获取列表元素，以及执行各种常见的列表操作。除此之外，列表还可以用来存储任务信息、最近浏览过的文章或者常用联系人信息。  
列表的一个主要优点在于它可以包含多个字符串值，这使得用户可以将数据集中在同一个地方。redis的集合也提供了与列表类似的特性，但集合只能保存各不相同的元素。

### 3.3 集合
redis的集合以无序的方式来存储多个各不相同的元素，用户可以快速地对集合执行添加元素操作、移除元素操作以及检查一个元素是否存在于集合中。  

### 3.4 散列
redis的散列可以让用户将多个键值对存储到一个redis键里面。从功能上来说，redis为散列值提供了一些与字符串相同的特性，使得散列非常适用于将一些相关的数据存储在一起。我们可以把这种数据聚集看作是关系数据库中的行，或者文档数据库中的文档。  

### 3.5 有序集合
和散列存储着键与值之间的映射类似，有序集合也存储着成员与分值之间的映射，并且提供了分值处理命令，以及根据分值大小有序地获取或扫描成员和分值的命令。  

### 3.6 发布与订阅
一般来说，发布与订阅的特点是订阅者listener负责订阅频道channel，发送者publisher负责向频道发送二进制字符串消息。每当有消息被发送至给定频道时，频道的所有订阅者都会收到消息。我们也可以把频道看作是电台，其中订阅者可以同时收听多个电台，而发送者则可以在任何电台发送消息。  

### 3.7 其他命令
首先是可以同时处理字符串、集合、列表和散列的SORT命令；之后是用于实现基本事务特性的MULTI命令和EXEC命令，这两个命令可以让用户将多个命令当作一个命令来执行；最后是几个不同的自动过期命令，它们可以自动删除无用数据。  

#### 3.7.1 排序
负责执行排序操作的sort命令可以根据字符串、列表、集合、有序集合和散列这5中键里面存储着的数据，对列表、集合以及有序集合进行排序。可以将SORT命令看作是SQL语言里的ORDER BY子句。  
使用SORT命令提供的选项可以实现以下功能：根据降序而不是默认的升序来排序元素；将元素看作是数字来进行排序，或者将元素看作是二进制字符串来进行排序；使用被排序元素之外的其他值作为权重来进行排序，甚至还可以从输入的列表、集合、有序集合以外的其他地方进行取值。  

### 3.7.2 基本的redis事务
redis有5个命令可以让用户在不被打断的情况下对多个键执行操作，它们分别是WATCH、MULTI、EXEC和UNWATCH、DISCARD。  
什么是redis的基本事务  
redis的基本事务需要用到MULTI命令和EXEC命令，这种事务可以让一个客户端在不被其他客户端打断的情况下执行多个命令。和关系数据库那种可以在执行的过程中进行回滚（rollback）的事务不同，在redis里面，被MULTI命令和EXEC命令包围的所有命令会一个接一个地执行，直到所有命令都执行完毕为止。当一个事务执行完毕之后，redis才会处理其他客户端的命令。  

### 3.7.3 键的过期时间
在使用redis存储数据的时候，有些数据可能在某个时间点之后就不再有用了，用户可以使用DEL命令显式地删除这些无用数据，也可以通过redis的过期时间expiration特性来让一个键在给定的时限timeout之后自动被删除。当我们说一个键“带有生存时间time to live”或者一个键“会在特定时间之后过期”时，redis会在这个键的过期时间到达时自动删除该键。  


## 第4章 数据安全与性能保障
redis的各个持久化选项，这些选项可以让用户将自己的数据存储到硬盘上面。接着本章将介绍如何通过redis的复制特性，把不断更新的数据副本存储到附加的机器上面，从而提升系统的性能和数据的可靠性。  

### 4.1 持久化选项
redis提供了两种不同的持久化方法来将数据存储到硬盘里面。一种方法叫快照（snapshotting），它可以将存在于某一时刻的所有数据都写入硬盘里面。另一种方法叫只追加文件（append-only file，AOF），它会在执行写命令时，将被执行的写命令复制到硬盘里面。这两种持久化方法既可以同时使用，又可以单独使用，在某些情况下甚至可以两种方法都不使用，具体选择哪种持久化方法需要根据用户的数据以及应用来决定。  
将内存中的数据存储到硬盘的一个主要原因是为了在之后重用数据，或者是为了防止系统故障而将数据备份到一个远程位置。另外，存储在redis里面的数据有可能是经过长时间计算得出的，或者有程序正在使用redis存储的数据进行计算，所以用户会希望自己可以将这些数据存储起来以便之后使用，这样就不必要重新计算了。  

#### 4.1.1 快照持久化
redis可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。在创建快照之后，用户可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本，还可以将快照留在原地以便重启服务器时使用。  
创建快照的办法有以下几种：  
客户端可以通过向redis发送BGSAVE命令来创建一个快照。对于支持BGSAVE命令的平台来说，redis会调用fork来创建一个子进程，然后子进程复杂将快照写入硬盘，而父进程则继续处理命令请求。  
客户端还可以通过向redis发送SAVE命令来创建一个快照，接到SAVE命令的redis服务器在快照创建完毕之前将不再响应任何其他命令。SAVE命令并不常用，我们通常只会在没有足够内存去执行BGSAVE命令的情况下，又或者即使等待持久化操作执行完毕也无所谓的情况下，才会使用这个命令。  
如果用户设置了save配置选项，比如save 60 10000，那么从redis最近一次创建快照之后开始算起，当“60s之内有10000次写入”这个条件被满足时，redis就会自动触发BGSAVE命令，如果用户设置了多个save配置选项，那么当任意一个save配置选项所设置的条件被满足时，redis就会触发一次BGSAVE命令。  
当redis通过SHUTDOWN命令接收到关闭服务器的请求时，或者接收到标准TERM信号时，会执行一个SAVE命令，阻塞所有客户端，不再执行客户端发送的任何命令，并在SAVE执行完毕之后关闭服务器。  
当一个redis服务器连接另一个redis服务器，并向对方发送SYNC命令来开始一次复制操作的时候，如果主服务器目前没有在执行BGSAVE操作，或者主服务器并非刚刚执行完BGSAVE操作，那么主服务器就会执行BGSAVE命令。  
在只使用快照持久化来保存数据时，一定要记住：如果系统真的发生崩溃，用户将丢失最近一次生成快照之后更改的所有数据。因此，快照持久化只适用于那些即使丢失一部分数据也不会造成问题的应用程序，而不能接受这种数据损失的应用程序则可以考虑使用AOF持久化。  

#### 4.1.2 AOF持久化
简单来说，AOF持久化会将被执行的写命令写到AOF文件的末尾，以此来记录数据发生的变化。因此，redis只要从头到尾重新执行一次AOF文件包含的所有写命令，就可以恢复AOF文件所记录的数据集。AOF持久化可以通过设置appendonly yes配置选项来打开。appendfsync配置选项对AOF文件的同步频率。  
文件同步：在向硬盘写入文件时，至少会发生3件事。当调用file.write()方法对文件进行写入时，写入的内容首先会被存储到缓冲区，然后操作系统会在将来的某个时候将缓冲区存储的内容写入硬盘，而数据只有在被写入硬盘之后，才算是真正地保存到了硬盘里面。用户可以通过调用file.flush()方法来请求操作系统尽快地将缓冲区存储的数据写入硬盘里，但具体何时执行写入操作仍然由操作系统决定。除此之外，用户还可以命令操作系统将文件同步到硬盘，同步操作会一直阻塞直到指定的文件被写入硬盘为止。当同步操作执行完毕之后，即使系统出现故障也不会对被同步的文件造成任何影响。  

#### 4.1.3 重写/压缩AOF文件
为了解决AOF文件体积不断增大的问题，用户可以向redis发送BGREWRITEAOF命令，这个命令会通过移除AOF文件中的冗余命令来重写（rewrite）AOF文件，使AOF文件的体积变得尽可能地小。

### 4.2 复制
关系数据库通常会使用一个主服务器向多个从服务器发送更新，并使用从服务器来处理所有读请求。redis也采用了同样的方法来实现自己的复制特性，并将其用作扩展性能的一种手段。  
在需要扩展读请求的时候，或者在需要写入临时数据的时候，用户可以通过设置额外的redis从服务器来保存数据集的副本。在接收到主服务器发送的数据初始副本之后，客户端每次向主服务器进行写入时，从服务器都会实时地得到更新。在部署好主从服务器之后，客户端就可以向任意一个从服务器发送读请求了，而不必再像之前一样，总是把每个读请求都发送给主服务器。  

### 4.2.1 对redis的复制相关选项进行配置


### 4.4 redis事务
为了保证数据的正确性，我们必须认识到这一点：在多个客户端同时处理相同的数据时，不谨慎的操作很容易会导致数据出错。  
redis的事务和传统关系数据库的事务并不相同。在关系数据库中，用户首先向数据库服务器发送BEGIN，然后执行各个相互一致（consistent）的写操作和读操作，最后，用户可以选择发送COMMIT来确认之前所做的修改，或者发送ROLLBACK来放弃那些修改。  

#### 4.4.1 定义用户信息和用户包裹
