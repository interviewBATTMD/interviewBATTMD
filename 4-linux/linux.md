# Linux

## Linux用户态和内核态的理解和区别
https://blog.csdn.net/qq_39823627/article/details/78736650?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.add_param_isCf&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.add_param_isCf  
1、地址空间：用户空间+内核空间  
2、特权级不同  
3、用户态和内核态的切换：  
（1）系统调用  
（2）异常  
（3）外围设备的中断
中断和异常的异同：  
》1-最后都是由CPU发送给内核，由内核去处理  
》2-处理程序的流程设计上是相似的  
》3-产生源不同，异常是由CPU产生，中断是由硬件设备产生的  
》4-内核需要根据是异常还是中断调用不同的处理程序
》5-中断不是时钟同步的，这意味着中断可能随时到来，异常由于是CPU产生的，所以它是时钟同步的。  
》6-当处理中断时，处理中断上下文中，处理异常时，处于进程上下文中。

## 线程和进程
https://www.cnblogs.com/sky-heaven/p/8204614.html
### Linux线程实现机制
线程模型，有核心级线程和用户级线程两种线程模型，分类的标准主要是线程的调度者在核内还是在核外，前者更利于并发使用多处理器的资源，后者更多考虑的是上下文切换开销。

### 线程和进程的区别

### 多核的情况下，如何让进程运行在指定核上

### Linux进程调度器
https://blog.csdn.net/gatieme/article/details/51699889  
**2个调度器**  

### 线程同步方式有哪些？  
互斥锁，自旋锁，读写锁、条件变量  
C++ STL实现的方案：  
C++11 mutex、condition_variable
C++17 读写锁shared_mutex https://blog.csdn.net/gongjianbo1992/article/details/100061344  
C++20 信号量#include<semaphore>  

Linux系统调用pthread实现：  

### 互斥锁和自旋锁的区别，自旋锁的应用场景  
https://blog.csdn.net/qq_26093511/article/details/78634288  
从实现原理上来讲，Mutex属于sleep-waiting类型的锁。没有获得锁线程就会被阻塞。  
自旋锁属于busy-waiting类型的锁，会一直不停地去请求锁。  
自旋锁不会引起调用者阻塞，所以自旋锁的效率远高于互斥锁。  
然后自旋锁一直占用CPU，如果不能在短时间内获得锁，会使CPU效率降低。  
》》mutex导致线程阻塞  
mutex导致线程阻塞，使得线程停止执行，释放CPU，会涉及线程（上下文）切换的问题，如果频繁进行线程切换的话，对性能的消耗还是挺大的，自旋锁（这里指pthread实现，非STL11mutex模拟）则不会涉及线程切换的问题，因为一直再运行状态，但是自旋锁也会涉及内核态到用户态的转换  
》》pthread mutex实现  
https://blog.csdn.net/weixin_30348519/article/details/97269843  
从2.6.x内核之后，Linux的mutex都是futex（Fast-Usermode-muTEX）锁。  
futex（快速用户区互斥的简称）是一个在Linux上实现锁定和构建高级抽象锁如信号量和POSIX互斥的基本工具。  
Futex是由用户空间的一个对齐的整型变量和附在其上的内核空间等待队列构成，多进程或多线程绝大多数情况下对位于用户空间的futex的整型变量进行操作（汇编语言调用CPU提供的原子操作指令来增加或减少），而其他情况下，则需要通过代价较大的系统调用来对位于内核空间的等待队列进行操作（如唤醒等待的进程/线程，或将当前进程/线程放入等待队列）。除了多个线程同时竞争锁的少数情况外，基于futex的lock操作是不需要进行代价昂贵的系统调用操作的。  
这种机制的核心思想是通过将大多数情况下非同时竞争lock的操作放到在用户空间来执行，而不是代价昂贵的内核系统调用方式来执行，从而提高了效率。  

## 可重入函数和线程安全函数
可重入函数：多个执行流反复执行一个函数，其结果不会发生改变。  
线程安全函数：多个线程并发调用同一个函数时，不会出现乱序或者错误结果，我们可以说是线程安全的。  
可重入函数以一定是线程安全的，但是线程安全是可重入函数。  
例如close()是可重入函数，但是不是线程安全的，如果两个线程同时close()操作，会core dump。  

## mmap和fread的区别（mmap是映射全部的内存吗），[缺页中断和缓冲读入]什么时候去用哪个
https://blog.csdn.net/don_chiang709/article/details/89332295  
系统调用中的write和read：  
在真正的把用户数据读写到磁盘或者是存储设备前，内核还会再page cache中管理这些数据。这些page的存在有效的管理了用户数据和读写的效率。用户数据不是直接来自于应用层，读（read）或者是写入（write）磁盘和存储介质，而是被一层一层的应用所划分，在每一层次中都会有不同的功能对应。最后发生交互时，在最恰当的时机触发磁盘的操作。通过IO驱动写入磁盘和存储介质。这里主要强调page cache的管理。应为page的管理涉及到了缓存，这些缓存以page的单位管理。在没有IO操作之前，暂时存放在系统空间中，而并未直接写入磁盘或者存储介质。  
系统调用中的mmap：  
当创建一个或者切换一个进程的同时，会把属于这个当前进程的系统信息载入。这些系统信息中包含了当前进程的运行空间。当用户程序调用mmap后。函数会在当前进程的空间中找到适合的vma来描述自己将要映射的区域。这个区域的作用就是将mmap函数中文件描述符所指向的具体文件中内容映射过来。  
原理是：mmap的执行，仅仅是在内核中建立了文件与虚拟内存空间的对应关系。用户访问这些虚拟内存空间时，页面表里面没有这些空间的表项的。当用户程序试图访问这些映射的空间时，于是产生缺页异常。内核捕捉这些异常，逐渐将文件载入。  
为什么fread的效率达不到最大呢，用fread和fwrite方式访问硬盘，用户需向内核指定要读多少，内核再把得到的内容从内核缓冲池拷贝到用户空间；写也是如此。这样在访问IO的时候就多经历了这么一个内核的buffer，造成速度的限制。一个解决的办法是mmap。mmap就是通过把文件的某一块内容直接映射到用户空间上，用户可以直接向内核缓冲池读写这一块内容，这样一来就少了内核与用户空间的来回拷贝所有通常更快。  

## 虚拟内存、缺页中断、抖动
虚拟内存是计算机系统内存管理的一种技术，它使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。与没有使用虚拟内存计数的系统相比，使用这种技术的系统使得大型程序的编写变得更容易，对真正的物理内存的使用也更有效率。  
缺页中断一个页page是一个固定容量的内存区块，是物理内存和外部存储（如硬盘等）传输的单位。当一个程序访问一个映射到地址空间却实际未加载到物理内存的页page时，硬件向软件发出一次中断或异常就是一个缺页中断或者page fault  



## Linux 命令
### free命令
```
free -h
```
会显示2行，一行是Mem，一行是Swap，Mem是内存空间，Swap是交换空间（一般是磁盘了）。  
Mem ： total used free shared buff/cache available  
total是内存总大小，used是使用内存的大小，free是空闲内存大小，shared是多个进程共享的内存总额，buff/cache中buffer指buffer cache，cache指page cache，page cache主要用来作为文件系统上的文件数据的缓存来用，尤其针对当进程对文件有read/write操作的时候。buffer cache则主要是设计用来在系统对块设备进行读写的时候，对块进行数据缓存的系统来使用。https://blog.csdn.net/lqglqglqg/article/details/82313966  

total = used + free + buff/cache  
available = free + buffer + cache（当没有足够的free空间时，会从buffer和cache中回收内存，当然不是全部剥夺，所以这里的“=”两边数值不一定相等）。  

### kill命令
```
kill PID
```
发送指定的信号到相应进程，如果不指定信号则发送SIGTERM(15)终止指定进程，如果无法终止该进程，可以向进程号发送SKILL(9)信号，该信号将强制结束进程。  


### traceroute命令
traceroute可以知道数据从你的计算机到互联网另一端主机是走的什么路径。当然每次数据包由某一同样的出发点到达某一同样的目的地走的路径可能不一样，但基本上来说大部分时候所走的路由是相同的。  
