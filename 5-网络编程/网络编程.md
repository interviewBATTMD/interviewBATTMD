# 网络编程

## TCP UDP
### TCP三次握手四次挥手
<font color=#ffff00>1、TCP三次握手说一下</font>  
客户端向服务端发送SYN报文，SYN标志位置1，序列号为X，服务端收到后发送ACK确认报文，SYN置1，ACK置1，ACKnum=X+1，序列号为Y；客户端接收到ACK报文后，再向服务端发送ACK报文，SYN=1，ACK=1，ACKnum=Y+1，序列号为X+1

2、如果第三次握手的ack丢失会怎样
当client端收到server的SYN+ACK应答后，其状态变为ESTABLISHED，并发送ACK包给server。如果此时ACK在网络中丢失，那么server端该tcp连接的状态SYN_RECV，并且依次等待3秒、6秒、12秒后重新发送SYN+ACK包，以便client重新发送ACK包，server重发SYN+ACK包的次数，可以通过设置/proc/sys/net/ipv4/tcp_synack_retries修改，默认值为5。如果重发指定次数后，仍然未收到ACK应答，那么一段时间后，server自动关闭这个连接。但是client认为这个连接已经建立，如果client端向server写数据，server端将以RST包响应，方能感知到server的错误。  

3、第二次握手服务端会将连接放到半连接队列，那你知道SYN攻击吗，怎么解决  
SYN泛洪攻击，通过发送大量SYN包使服务端产生大量半连接，消耗服务器资源。  
解决方法：a、减小timeout时间；b、使用SYN cookie

4、SYN cookie具体如何实现
<font color=#ff0000>TODO 具体实现</font>  

5、三次握手过程中可以携带数据吗？
其实第三次握手的时候，是可以携带数据的。但是，第一次、第二次握手不可以携带数据  
主要是避免受到攻击时消耗资源。三次握手建立就完成了，此时携带数据没问题。 

6、TIME_WAIT状态的作用  
四次挥手最后阶段，client端进入TIME_WAIT状态，并且持续2MSL时间长度，MSL就是maximum segment lifetime，这是一个IP数据包能在互联网上生存的最长时间。TIME_WAIT状态的作用是为了client发出的确认包丢失后则还会重发一个确认包，否则，server未收到确认包，会重发FIN报文，而client则不能正常响应，只返回RST包。  

7、拥塞控制方法  
慢开始、拥塞避免、快恢复、快重传  
慢开始：开始发数据的时候，只有几个MSS长度，之后每经过一轮传输轮次，发送的数据翻倍（增大拥塞窗口）。
拥塞避免：慢开始后数据不断增长，达到慢开始门限后，启动拥塞避免算法，完成一轮传输轮次后线性增加窗口大小+1  
快重传：发端收到3个相同的回复后立即进行重传。  
快恢复：当出现丢失个别包后，不进行慢开始而是进行快恢复，将门限降至原来一半。

8、TTL是什么
Time to Live，一般指的是跳数  

9、TCP的四次挥手  
客户端发送FIN报文，服务端收到FIN报文后，发送ACK确认报文，继续处理没有发送完的数据，之后发送FIN报文，客户端收到FIN报文，回复ACK报文，等待2个MSL之后关闭连接。  

10、TIME_WAIT状态下的等待时间是多少，为何是2MSL  
2MSL，第一，为了保证客户端发送的最后一个ACK报文能够到达服务器。这个ACK报文段有可能丢失，因而使处在LAST-ACK状态的服务端收不到对已发送的FIN+ACK报文段的确认。服务端会超时重传这个FIN+ACK报文段，而客户端就能在2MSL时间内收到这个重传的FIN+ACK报文段。如果客户端在TIME-WAIT状态不等待一段时间，而是在发送完ACK报文段后就立即释放连接，就无法收到B重传的FIN+ACK报文段，因而也不会再发送一次确认报文段。这样，B就无法按照正常的步骤进入CLOSED状态  
二是，客户端在发送完ACK报文后，在经过2MSL时间，就可以使本连接持续时间所产生的所有报文段在网络中消失。  
》》MSL和TTL的关系？  
TTL与MSL是有关系的但不是简单的相等的关系，MSL要大于等于TTL。（虽然TTL从字面上翻译，是可以存活的时间，但实际上TTL是IP数据包在计算机网络中可以转发的最大跳数。）  

11、出现向已关闭的socket写数据的情况，会出现什么情况  
会产生SIGPIPE信号，一般都会设置忽略SIGPIPE信号。  
```
struct sigaction sa;
memset(&sa, 0, sizeof(struct sigaction));
sa.sa_handler = SIG_IGN;
sigemptyset(&sa.sa_mask);
if (-1 == sigaction(SIGPIPE, &sa, NULL)) {
    cout << "ignore SIGPIPE failed." << endl;
    exit(1);
}
```
https://www.cnblogs.com/wblyuyang/archive/2012/11/13/2768923.html  

12、connect 使用的套接字可以设置成非阻塞吗  
可以  
https://blog.csdn.net/xiaofei0859/article/details/77141575  

13、TCP连接拔掉网线后会发生什么  
当客户端与服务器建立起正常的TCP连接后，如果客户主机网线断开、电源掉电或系统崩溃，服务器进程将永远不会知道（通过我们常用的select，epoll监测不到断开或错误事件），如果不主动处理或重启系统的话对于服务端来说会一直维持着这个连接，任凭服务端进程如何望穿秋水，也永远等不到客户端的任何回应，这种情况就是半开连接，浪费了服务端可用的文件描述符。  
说明网线断开对端是不能做任何感知的，除非我们配置操作系统的SO_KEEPALIVE选项，或者进行应用层心跳检测。  
1、如果网线断开的时间短暂，在SO_KEEPALIVE设定的探测时间间隔内，并且两端在此期间没有任何针对此长连接的网络操作。当连上网线后此TCP连接可以自动恢复，继续进行正常的网络操作。  
2、如果网线断开的时间很长，超出了SO_KEEPALIVE设定的探测时间间隔，或者两端期间在此有了任何针对此长连接的网络操作。当连上网线时就会出现ETIMEDOUT或者ECONNRESET的错误。你必须重新建立一个新的长连接进行网络操作。  

### TCP UDP区别
1、tcp是面向字节流的可靠的传输协议，udp是面向报文的尽可能交付的传输协议  
2、tcp支持端到端传输，udp除了支持端到端传输还支持多播  
3、tcp通过流量控制和拥塞控制和重传机制和确认机制等来保证数据正确有序地传输，udp则没有tcp的这些可靠机制  
4、udp比tcp快，udp包头只有8字节，而tcp包头至少20字节，tcp的可靠机制也会消耗计算和带宽资源，以及限制机制，导致tcp会比udp慢些（同等情况下）

## 网络分层模式
物理层-数据链路层-网络层-传输层-会话层-表示层-应用层  
数据链路层-网络层-传输层-应用层

## Socket
https://blog.csdn.net/qq_14978113/article/details/80738787  
进程间通信  
进程间通信（IPC，Interprocess communication）是一组编程接口，协调不同的进程，使之能在一个操作系统里同时运行，这些接口给多个进程之间交换信息提供了可能。比较常见的几种跨进程通信方式有：管道（PIPE）、有名管道（FIFO）、消息队列、信号量、共享内存、套接字（socket）等。  
* Pipe：一般指无名管道，只能用于有亲缘关系的父子进程或者兄弟进程间的通信，半双工，数据只能由一端流向另一端。  
* FIFO：有名管道可以在无关的进程间通信。  
* 消息队列：消息队列由kernel维护的消息链表，一个消息队列由一个标志符确定
* 信号量：信号量是一个计数器，用于控制多个进程对资源的访问，主要用于实现进程间互斥与同步，不能传递复杂消息
* 共享内存：由一个进程创建，多个进程可以共享的内存段，需要结合信号量来同步对共享内存的访问  
* socket：网络上的两个程序通过一个双向的通信连接实现数据的交换。  


## ping的原理
ping命令使用icmp协议，主要是测试网络的连通性，icmp属于网络层协议。  
ping的若是网址，则还会涉及DNS协议，DNS解析——  
icmp通过路由去寻址，如果本地host缓存中没有缓存，则走ARP请求Mac地址，ARP协议是局域网下使用，若是局域网下没有，则通过路由器去寻址，对应局域网下进行ARP请求，获得Mac地址，在通过路由发送回来，这样也就知道ip对应的mac地址。  

## IO复用
1、LT模式和ET模式的区别  
LT模式和ET模式的区别，主要是LT模式下调用epoll_wait后这次没处理完事件下一次调用epoll_wait还是提醒你之前没处理完的事件；ET模式下调用epoll_wait后这次没处理完的事件下一次调用epoll_wait不会再提醒。epoll默认是LT模式，设置ET模式时需要设置O_NONBLOCK。  

2、EAGAIN含义  
以O_NONBLOCK的标识打开文件/socket/FIFO，如果你连续read操作而无数据可读，此时程序不会阻塞起来等待数据准备就绪返回，read函数会返回一个错误EAGAIN，提示你的应用程序现在没有数据可读请稍后再试。  


## HTTP

### HTTP用什么分割包头包体的  
HTTP请求内容：请求行，请求头，空行，请求体  
常用，一个有报文的请求到服务器时，请求头里都会有content_length，这个指定了报文的大小，报文如果很大的时候，会通过一部分一部分的发送请求，直到结束，当这个过程中，出现多个请求，第一个请求会带有请求头信息，前面一个请求的如果发送的报文没有满时，会把后面一个请求的内容填上，这个操作就叫粘包。这样粘包后，会通过content_length字段的大小，来做拆包。  
